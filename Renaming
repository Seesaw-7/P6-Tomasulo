module RegisterRenaming (
    input logic clk,
    input logic reset,
    input logic [4:0] arch_reg_src1, 
    input logic [4:0] arch_reg_src2,
    input logic [4:0] arch_reg_dest,
    input logic commit, //from ROB 
    input logic [4:0] commit_phys_reg, 
    output logic [4:0] phys_reg_src1,
    output logic [4:0] phys_reg_src2,
    output logic [4:0] phys_reg_dest
);

endmodule


module RAT (
    input logic clk,
    input logic reset,
    input logic [4:0] arch_reg_src1,
    input logic [4:0] arch_reg_src2,
    input logic [4:0] arch_reg_dest,
    input logic [4:0] allocate_reg,
    output logic [4:0] phys_reg_src1,
    output logic [4:0] phys_reg_src2
);

endmodule 


module FreeList (
    input logic clk,
    input logic reset,
    input logic assign_flag, 
    input logic return_flag, //from ROB
    input logic [4:0] return_reg,  
    output logic [4:0] assign_reg //phys_reg_dest
);

    logic [4:0] free_list [31:0];
    logic [4:0] free_list_front; //assign
    logic [4:0] free_list_end; //return

    //initialize free list (start as full)
    initial begin
        for (int i=0; i<32; i++) begin
            free_list[i] = i;
        end
        free_list_front = 5'b00000;
        free_list_end = 5'b11111; 
    end
    
    //assign phys_reg for new instruction and return phys_reg from ROB
    always_ff @(posedge clk) begin
        if (reset) begin
            for (int i=0; i<32; i++) begin
            free_list[i] = i;
            end
            free_list_front = 5'b00000;
            free_list_end = 5'b11111; 
        end
        else begin
            if (assign_flag) begin
            assign_reg = free_list[free_list_front];
            free_list_front = (free_list_front + 1) % 32;
            end
            if (return_flag) begin
            free_list[(free_list_end + 1) % 32] = return_reg;
            free_list_end = (free_list_end + 1) % 32;
        end
    end
        
endmodule


